# Dynamic

## Envelope Follower

An envelope follower is a device or algorithm used to track the amplitude envelope of an signal over time. Think of it as a tool that measures how loud or quiet a sound is at any given moment.

Here's how it typically works:

1. **Signal Input:** The envelope follower takes in an signal as input. This could be a microphone picking up sound, a recorded track, or any other source of audio.
2. **Envelope Detection:** The device or algorithm analyzes the input signal to detect changes in its amplitude or volume. It focuses on the overall shape or contour of the sound rather than the specific frequencies.
3. **Output Control:** The envelope follower generates a control signal that reflects the changes in the input signal's amplitude. This control signal can then be used to modulate other parameters, such as the volume of another signal, the cutoff frequency of a filter, or the intensity of an effect.

Envelope followers are commonly used in audio processing, synthesis, and effects applications. For example, they're often employed in dynamic effects like compression or gating, where the level of one audio signal is controlled by the envelope of another. They can also be used creatively in synthesis to modulate parameters like filter cutoff or oscillator pitch, adding dynamic movement to sounds.

```{python}
#| lst-label: lst-env-follower-python
#| lst-cap: Enveloper Follower in Python
import numpy as np

class EnvelopeFollower:
    def __init__(self, attack, release, target, sr):
        self.attack = attack
        self.release = release
        self.target = target
        self.sr = sr

    def process(self, x):
        target = np.log(self.target)
        attack = np.exp(target / (self.attack * self.sr * 0.001))
        release = np.exp(target / (self.release * self.sr * 0.001))

        y = np.copy(x)
        state = 0.0
        for n, _ in enumerate(x):
            env = np.abs(y[n])
            coef = attack if env > state else release
            state = coef * (state - env) + env
            y[n] = state
        return y
```
```{python}
#| echo: false
#| fig-cap: "Envelope Follower Output (Target -50dB)"
import matplotlib.pyplot as plt

def to_db(x):
    offset = 1e-9
    return 20*np.log10(x+offset)

def from_db(x):
    return 10.0**(x*0.05)


sr = 44100
target = from_db(-50)
t = np.linspace(0, 1, sr)
sig = np.zeros(sr)
sig[0:(sr//10)*2] = 1

fig, ((ax1, ax2),(ax3, ax4)) = plt.subplots(2, 2, constrained_layout=True)

ax1.plot(t, sig, "k:")
ax1.plot(t, EnvelopeFollower(50, 600, target, sr).process(sig), "k-")
ax1.grid(which="major", linewidth=1)
ax1.grid(which="minor", linewidth=0.2)
ax1.tick_params(axis='x', labelsize="small")
ax1.tick_params(axis='y', labelsize="small")
ax1.set_title("Attack 50 ms, Release 600ms", fontsize="small")
# ax1.minorticks_on()

ax2.plot(t, to_db(sig), "k:")
ax2.plot(t, to_db(EnvelopeFollower(50, 600, target, sr).process(sig)), "k-")
ax2.grid(which="major", linewidth=1)
ax2.grid(which="minor", linewidth=0.2)
ax2.tick_params(axis='x', labelsize="small")
ax2.tick_params(axis='y', labelsize="small")
ax2.set_title("Attack 50 ms, Release 600ms", fontsize="small")
# ax2.minorticks_on()

ax3.plot(t, sig, "k:")
ax3.plot(t, EnvelopeFollower(200, 200, target, sr).process(sig), "k-")
ax3.grid(which="major", linewidth=1)
ax3.grid(which="minor", linewidth=0.2)
ax3.tick_params(axis='x', labelsize="small")
ax3.tick_params(axis='y', labelsize="small")
ax3.set_title("Attack 200 ms, Release 200ms", fontsize="small")
# ax3.minorticks_on()

ax4.plot(t, to_db(sig), "k:")
ax4.plot(t, to_db(EnvelopeFollower(200, 200, target, sr).process(sig)), "k-")
ax4.grid(which="major", linewidth=1)
ax4.grid(which="minor", linewidth=0.2)
ax4.tick_params(axis='x', labelsize="small")
ax4.tick_params(axis='y', labelsize="small")
ax4.set_title("Attack 200 ms, Release 200ms", fontsize="small")
# ax4.minorticks_on()

plt.show()
```

## Compressor

```{python}
#| echo: false
#| fig-cap: "Hard vs Soft-Knee Gain Computer"
from IPython.display import display, display_latex, Math, Latex
import matplotlib.pyplot as plt
import numpy as np
import sympy
from sympy.utilities.lambdify import lambdify

x = sympy.Symbol('x', real=True)
T = sympy.Rational(-24, 1)
R = sympy.Rational(6, 1)
W = sympy.Rational(18, 1)

# Hard-Knee
hard = sympy.Piecewise((x, sympy.Le(x, T)), (T+(x-T)/R, True))

# Soft-Knee
soft = sympy.Piecewise(
    (x, sympy.Lt(2*(x-T), -W)),
    (x+(1/R-1)*((x-T+W/2)**2)/(2*W), sympy.Le(2*sympy.Abs(x-T), W)),
    (T+(x-T)/R, sympy.Gt(2*(x-T), W)),
)

x_in = np.linspace(-36.0, 0.0, 256)
hard_out = lambdify(x, hard, 'numpy')(x_in)
soft_out = lambdify(x, soft, 'numpy')(x_in)

plt.plot(x_in, hard_out, 'k', label="Hard-Knee")
plt.plot(x_in, soft_out, 'k:', label="Soft-Knee")
plt.grid()
plt.legend()
plt.show()
```


```{python}
#| echo: false
T = sympy.Symbol('T')
R = sympy.Symbol('R')
W = sympy.Symbol('W')
f = sympy.Piecewise((x, sympy.Le(x, T)), (T+(x-T)/R, True))
display_latex(f"$${sympy.latex(f)}$$", raw=True)
```



```{python}
#| echo: false
T = sympy.Symbol('T')
R = sympy.Symbol('R')
W = sympy.Symbol('W')
f = sympy.Piecewise(
    (x, sympy.Lt(2*(x-T), -W)),
    (x+(1/R-1)*((x-T+W/2)**2)/(2*W), sympy.Le(2*sympy.Abs(x-T), W)),
    (T+(x-T)/R, sympy.Gt(2*(x-T), W)),
)
display_latex(f"$${sympy.latex(f)}$$", raw=True)
```




## Limiter

## Expander

## Transient Shaper

An audio transient shaper is a type of audio effect that is used to modify the transient (attack and decay) characteristics of an audio signal. Transient shaping is often used to alter the perceived punch, clarity, and energy of a sound, and it can be applied to a wide range of audio material, including drums, percussion, bass, and vocals.

There are a number of different approaches that can be used to implement an audio transient shaper effect, but one common method is to use a compressor or envelope follower to detect the transients in the audio signal, and then apply gain modification to the transients based on a user-specified curve.

Here is an example of how an audio transient shaper effect could be implemented in Python using the NumPy library:

```{python}
#| lst-label: lst-transient-shaper-python
#| lst-cap: Transient Shaper in Python
import numpy as np

def transient_shaper(audio, curve, threshold=0.1, ratio=2.0, attack=5, release=50):
  # Create an envelope follower using a compressor
  envelope = np.zeros(len(audio))
  for i in range(1, len(audio)):
    if abs(audio[i]) > envelope[i-1]:
      envelope[i] = attack * (abs(audio[i]) - envelope[i-1]) + envelope[i-1]
    else:
      envelope[i] = release * (abs(audio[i]) - envelope[i-1]) + envelope[i-1]

  # Apply gain modification to the transients based on the curve
  for i in range(len(audio)):
    if envelope[i] > threshold:
      audio[i] *= curve[int(envelope[i] * len(curve))]

  return audio

# Example usage: apply a transient shaper curve to an audio signal
audio = np.random.random(44100)  # generate a random audio signal
curve = np.linspace(0, 2, 100)  # create a linear transient shaper curve
#audio = transient_shaper(audio, curve)  # apply the transient shaper to the audio
```

This example defines a function transient_shaper that takes an audio signal and a transient shaper curve as inputs, and applies gain modification to the transients in the signal based on the curve. The function first uses a compressor to detect the transients in the signal, and then applies gain modification to the transients based on the curve. The curve can be specified by the user and can take any form, such as a linear curve or a more complex curve with multiple segments.

Keep in mind that this is just one way to implement an audio transient shaper effect, and there are other approaches that may be more suitable for different applications. The specific implementation will depend on the desired behavior and characteristics of the effect.
